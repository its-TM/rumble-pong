<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rumble Pong Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.16/addons/p5.sound.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: "Press Start 2P", cursive;
      background: black;
      color: white;
      height: 100%;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }

    canvas {
      border: 2px solid #00ff00;
      display: block;
    }

    .menu-button {
      position: fixed;
      top: 20px;
      left: 20px;
      font-family: "Press Start 2P", cursive;
      padding: 10px 14px;
      font-size: 10px;
      color: #00ff00;
      border: 2px solid #00ff00;
      background: transparent;
      cursor: pointer;
      transition: transform 0.2s;
      white-space: nowrap;
      text-decoration: none;
    }

    .menu-button:hover {
      transform: scale(1.05);
      background: rgba(0, 255, 0, 0.1);
    }

    @media (max-width: 600px) {
      .menu-button {
        font-size: 8px;
        padding: 6px 10px;
      }
    }
  </style>
</head>
<body>
  <a href="Main Menu.html" class="menu-button">‚Üê Back to Menu</a>

  <script>
    let leftscore = 0;
    let rightscore = 0;
    let puck, left, right;
    let audioEnabled = true;
    let gameStarted = false;
    let showStartScreen = true;
    let canvas;
    let countdownStarted = false;
    
    // Power-up variables for each player
    let leftStoredPowerup = null; // Stores the powerup for player 1
    let rightStoredPowerup = null; // Stores the powerup for player 2
    let leftPowerupCooldownEnd = 0; // When player 1 can get a new powerup
    let rightPowerupCooldownEnd = 0; // When player 2 can get a new powerup

    // Existing power-up effect tracking
    let leftPowerupActive = false;
    let rightPowerupActive = false;
    let leftPowerupEffectEndTime = 0; // Changed name for clarity
    let rightPowerupEffectEndTime = 0; // Changed name for clarity
    let ballFrozen = false;
    let ballFrozenEndTime = 0;
    let ballSpeedMultiplier = 1;

    // New Power-up variables
    let magicActive = false;
    let magicEffectEndTime = 0;
    const MAGIC_DURATION = 5000; // 5 seconds

    let forceFieldActive = { left: false, right: false };
    let forceFieldEffectEndTime = { left: 0, right: 0 };
    const FORCE_FIELD_DURATION = 4000; // 4 seconds

    let brokenKeyboardActive = { left: false, right: false }; // Tracks if the *other* player's controls are reversed
    let brokenKeyboardEffectEndTime = { left: 0, right: 0 };
    const BROKEN_KEYBOARD_DURATION = 5000; // 5 seconds


    let leftOriginalHeight = 100; // Store original height
    let rightOriginalHeight = 100; // Store original height
    let powerupImages = {};

    const POWERUP_TYPES = ['freeze', 'fireball', 'xl', 'mini', 'magic', 'forcefield', 'brokenKeyboard'];
    const POWERUP_COOLDOWN_DURATION = 8000; // 8 seconds before a new powerup is given
    const POWERUP_EFFECT_DURATION = 3000; // 3 seconds for most effects (used for freeze, fireball, xl, mini)

    const GAME_WIDTH = 800;
    const GAME_HEIGHT = 600;
    let scaleFactor = 1;
    let retroFont; // Declare retroFont globally

    // Load powerup images (placeholder names)
    function preload() {
      // Note: These would be actual image files in a real implementation
      // For now, we'll create placeholder colored rectangles
      soundFormats('mp3', 'ogg');
      retroFont = loadFont('/data/PressStart2p.ttf');
      goalSound = loadSound("/data/sfx/goal");
      countdown = loadSound("/data/sfx/countdown");
      countdown.setVolume(0.5);
      powerupImages.freeze = null; // freeze.png
      powerupImages.fireball = null; // fireball.png
      powerupImages.xl = null; // xl.png
      powerupImages.mini = null; // mini.png
      powerupImages.magic = null; // magic.png
      powerupImages.forcefield = null; // forcefield.png
      powerupImages.brokenKeyboard = null; // brokenKeyboard.png
    }

    class Paddle {
      constructor(isLeft) {
        this.w = 20;
        this.h = 100;
        this.originalH = 100; // Store initial height
        this.y = GAME_HEIGHT / 2;
        this.ychange = 0;
        this.x = isLeft ? this.w : GAME_WIDTH - this.w;
        this.isLeft = isLeft;
      }

      update() {
        this.y += this.ychange;
        this.y = constrain(this.y, this.h / 2, GAME_HEIGHT - this.h / 2);
      }

      move(steps) {
        this.ychange = steps;
      }

      show() {
        fill(255);
        rectMode(CENTER);
        rect(this.x, this.y, this.w, this.h);
      }

      resize(newHeight) {
        this.h = newHeight;
      }

      resetSize() {
        this.h = this.originalH;
      }
    }

    class Puck {
      constructor() {
        this.r = 12;
        this.reset();
        this.firstTime = true;
      }

      reset(xyz) {
        this.x = GAME_WIDTH / 2;
        this.y = GAME_HEIGHT / 2;
        let angle = random(-PI / 4, PI / 4);
        this.xspeed = 5 * cos(angle);
        this.yspeed = 5 * sin(angle);
        if (xyz === 1) this.xspeed *= -1;
        ballSpeedMultiplier = 1; // Reset ball speed
        ballFrozen = false; // Ensure ball is unfrozen on reset
        magicActive = false; // Ensure magic is off on reset
      }
      
      update() {
      if (!ballFrozen) {
        let lastAngleChange = 0;
        if (magicActive) {
          const currTime = millis();
          
          // Initialize lastAngleChange if it doesn't exist
          if (!this.lastAngleChange) {
            this.lastAngleChange = currTime;
          }
          
          // Check if 0.5 seconds (500ms) have passed
          if (currTime - this.lastAngleChange >= 600) {
            let newAngle = random(0, 2*PI);
            let currentSpeed = sqrt(this.xspeed * this.xspeed + this.yspeed * this.yspeed);
            this.xspeed = currentSpeed * cos(newAngle);
            this.yspeed = currentSpeed * sin(newAngle);
            
            if (this.xspeed > 0 && this.x > GAME_WIDTH / 2) this.xspeed *= -1;
            if (this.xspeed < 0 && this.x < GAME_WIDTH / 2) this.xspeed *= -1;
            
            // Update the last angle change time
            this.lastAngleChange = currTime;
            ballSpeedMultiplier = Math.max(ballSpeedMultiplier, 1.5);
          }
        }
        
        this.x += this.xspeed * ballSpeedMultiplier;
        this.y += this.yspeed * ballSpeedMultiplier;
      }
}

      edges() {
        if (this.y < 0 || this.y > GAME_HEIGHT) this.yspeed *= -1;

        // Check for goal conditions
        if (this.x - this.r > GAME_WIDTH) {
          leftscore++;
          goalSound.play(); // Play sound on goal
          this.reset(1);
        }
        if (this.x + this.r < 0) {
          rightscore++;
          goalSound.play(); // Play sound on goal
          this.reset(2);
        }
      }

      checkPaddle(p) {
        if (
          this.y - this.r < p.y + p.h / 2 &&
          this.y + this.r > p.y - p.h / 2 &&
          ((this.x - this.r < p.x + p.w / 2 && this.x > p.x) ||
           (this.x + this.r > p.x - p.w / 2 && this.x < p.x))
        ) {
          // Calculate angle based on where it hits the paddle
          let diff = this.y - (p.y - p.h / 2);
          let angle = map(diff, 0, p.h, p.x < GAME_WIDTH / 2 ? -PI / 4 : (5 * PI) / 4, p.x < GAME_WIDTH / 2 ? PI / 4 : (3 * PI) / 4);
          this.xspeed = 5 * cos(angle);
          this.yspeed = 5 * sin(angle);

          // Prevent ball from sticking to paddle
          this.x = p.x < GAME_WIDTH / 2 ? p.x + p.w / 2 + this.r : p.x - p.w / 2 - this.r;
        }
      }

      checkForceField(player) {
        let fieldX, fieldY, fieldRadius;
        if (player === 'left') {
          fieldX = left.x + left.w / 2 + 50; // Position the arc in front of the paddle
          fieldY = left.y;
          fieldRadius = 70;
          // Check if ball is within the arc's X range
          if (this.x + this.r > left.x + left.w / 2 && this.x - this.r < fieldX + fieldRadius) {
            // Check approximate collision with the arc
            let distToCenter = dist(this.x, this.y, fieldX, fieldY);
            if (distToCenter < fieldRadius + this.r && distToCenter > fieldRadius - this.r) {
              // Calculate angle from center of arc to ball
              let angleToBall = atan2(this.y - fieldY, this.x - fieldX);
              // Only bounce if ball is moving towards the field and within the arc's "front"
              if (this.xspeed < 0 && angleToBall > -PI/2 && angleToBall < PI/2) {
                this.xspeed *= -1; // Reverse X direction
                // Optional: Adjust Y speed based on hit point on the arc
                this.yspeed = (this.y - fieldY) * 0.1; // Example, can be more sophisticated
              }
            }
          }
        } else if (player === 'right') {
          fieldX = right.x - right.w / 2 - 50; // Position the arc in front of the paddle
          fieldY = right.y;
          fieldRadius = 70;
          // Check if ball is within the arc's X range
          if (this.x - this.r < right.x - right.w / 2 && this.x + this.r > fieldX - fieldRadius) {
            // Check approximate collision with the arc
            let distToCenter = dist(this.x, this.y, fieldX, fieldY);
            if (distToCenter < fieldRadius + this.r && distToCenter > fieldRadius - this.r) {
              // Calculate angle from center of arc to ball
              let angleToBall = atan2(this.y - fieldY, this.x - fieldX);
              // Only bounce if ball is moving towards the field and within the arc's "front"
              if (this.xspeed > 0 && (angleToBall > PI/2 || angleToBall < -PI/2)) {
                this.xspeed *= -1; // Reverse X direction
                // Optional: Adjust Y speed based on hit point on the arc
                this.yspeed = (this.y - fieldY) * 0.1; // Example, can be more sophisticated
              }
            }
          }
        }
      }

      show() {
        if (ballFrozen) {
          fill(100, 150, 255); // Blue tint when frozen
        } else if (ballSpeedMultiplier > 1) {
          fill(255, 100, 100); // Red tint when in fireball mode
        } else {
          fill(255);
        }
        ellipse(this.x, this.y, this.r * 2);
      }
    }

    function setup() {
      calculateCanvasSize();
      canvas = createCanvas(GAME_WIDTH * scaleFactor, GAME_HEIGHT * scaleFactor);
      canvas.parent(document.body);
      puck = new Puck();
      left = new Paddle(true);
      right = new Paddle(false);

      // Initialize powerup cooldowns for both players
      leftPowerupCooldownEnd = millis() + POWERUP_COOLDOWN_DURATION;
      rightPowerupCooldownEnd = millis() + POWERUP_COOLDOWN_DURATION;
    }

    function draw() {
      scale(scaleFactor);
      background(0);
      textFont(retroFont);
      if (showStartScreen) {
        fill(255);
        textAlign(CENTER);
        textSize(24);
        text("Rumble Pong!", GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50);
        textSize(16);
        text("Click to Start!", GAME_WIDTH / 2, GAME_HEIGHT / 2); // Prompt user to click
        textSize(12);
        text("Player 1: W/S   |   Player 2: I/K", GAME_WIDTH / 2, GAME_HEIGHT / 2 + 25);
        text("Press Q and P for Powerups!", GAME_WIDTH / 2, GAME_HEIGHT / 2 + 50);
        return;
      }

      // Update powerup cooldowns and effects
      updatePowerups();

      puck.checkPaddle(left);
      puck.checkPaddle(right);

      // Check for force field collisions
      if (forceFieldActive.left) {
        puck.checkForceField('left');
      }
      if (forceFieldActive.right) {
        puck.checkForceField('right');
      }

      left.update();
      right.update();
      puck.update();
      puck.edges();

      left.show();
      right.show();
      puck.show();

      // Draw UI
      drawUI();

      // Draw active force fields
      if (forceFieldActive.left) {
        drawForceField(left.x + left.w / 2 + 50, left.y, 'left');
      }
      if (forceFieldActive.right) {
        drawForceField(right.x - right.w / 2 - 50, right.y, 'right');
      }
    }

    function updatePowerups() {
      let currentTime = millis();
      
      // Check and give powerup for Player 1
      if (leftStoredPowerup === null && currentTime >= leftPowerupCooldownEnd) {
        leftStoredPowerup = random(POWERUP_TYPES);
        leftPowerupCooldownEnd = currentTime + POWERUP_COOLDOWN_DURATION; // Reset cooldown
      }

      // Check and give powerup for Player 2
      if (rightStoredPowerup === null && currentTime >= rightPowerupCooldownEnd) {
        rightStoredPowerup = random(POWERUP_TYPES);
        rightPowerupCooldownEnd = currentTime + POWERUP_COOLDOWN_DURATION; // Reset cooldown
      }

      // Check if ball freeze should end
      if (ballFrozen && currentTime >= ballFrozenEndTime) {
        ballFrozen = false;
      }

      // Check if fireball effect should end (ballSpeedMultiplier > 1 means it's active)
      if (ballSpeedMultiplier > 1 && currentTime >= ballFrozenEndTime) { // Using ballFrozenEndTime for fireball as well
        ballSpeedMultiplier = 1;
      }

      // Check if paddle size effects should end for Player 1
      if (leftPowerupActive && currentTime >= leftPowerupEffectEndTime) {
        left.resetSize();
        leftPowerupActive = false;
      }

      // Check if paddle size effects should end for Player 2
      if (rightPowerupActive && currentTime >= rightPowerupEffectEndTime) {
        right.resetSize();
        rightPowerupActive = false;
      }

      // Check if Magic effect should end
      if (magicActive && currentTime >= magicEffectEndTime) {
        magicActive = false;
      }

      // Check if Force Field effects should end
      if (forceFieldActive.left && currentTime >= forceFieldEffectEndTime.left) {
        forceFieldActive.left = false;
      }
      if (forceFieldActive.right && currentTime >= forceFieldEffectEndTime.right) {
        forceFieldActive.right = false;
      }

      // Check if Broken Keyboard effects should end
      if (brokenKeyboardActive.left && currentTime >= brokenKeyboardEffectEndTime.left) {
        brokenKeyboardActive.left = false;
      }
      if (brokenKeyboardActive.right && currentTime >= brokenKeyboardEffectEndTime.right) {
        brokenKeyboardActive.right = false;
      }
    }

    function activatePowerup(player) {
      let currentTime = millis();
      
      if (player === 'left' && leftStoredPowerup) {
        switch (leftStoredPowerup) {
          case 'freeze':
            ballFrozen = true;
            ballFrozenEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'fireball':
            ballSpeedMultiplier = 2;
            ballFrozenEndTime = currentTime + POWERUP_EFFECT_DURATION; // Use same timer for simplicity
            break;
          case 'xl':
            left.resize(left.originalH * 1.5); // Make left paddle 50% larger
            leftPowerupActive = true;
            leftPowerupEffectEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'mini':
            right.resize(right.originalH * 0.5); // Make right paddle 50% smaller
            leftPowerupActive = true;
            leftPowerupEffectEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'magic':
            magicActive = true;
            magicEffectEndTime = currentTime + MAGIC_DURATION;
            break;
          case 'forcefield':
            forceFieldActive.left = true;
            forceFieldEffectEndTime.left = currentTime + FORCE_FIELD_DURATION;
            break;
          case 'brokenKeyboard':
            brokenKeyboardActive.right = true; // Player 1 activates, Player 2's controls are reversed
            brokenKeyboardEffectEndTime.right = currentTime + BROKEN_KEYBOARD_DURATION;
            break;
        }
        leftStoredPowerup = null; // Powerup consumed
      } else if (player === 'right' && rightStoredPowerup) {
        switch (rightStoredPowerup) {
          case 'freeze':
            ballFrozen = true;
            ballFrozenEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'fireball':
            ballSpeedMultiplier = 2;
            ballFrozenEndTime = currentTime + POWERUP_EFFECT_DURATION; // Use same timer for simplicity
            break;
          case 'xl':
            right.resize(right.originalH * 1.5); // Make right paddle 50% larger
            rightPowerupActive = true;
            rightPowerupEffectEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'mini':
            left.resize(left.originalH * 0.5); // Make left paddle 50% smaller
            rightPowerupActive = true;
            rightPowerupEffectEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'magic':
            magicActive = true;
            magicEffectEndTime = currentTime + MAGIC_DURATION;
            break;
          case 'forcefield':
            forceFieldActive.right = true;
            forceFieldEffectEndTime.right = currentTime + FORCE_FIELD_DURATION;
            break;
          case 'brokenKeyboard':
            brokenKeyboardActive.left = true; // Player 2 activates, Player 1's controls are reversed
            brokenKeyboardEffectEndTime.left = currentTime + BROKEN_KEYBOARD_DURATION;
            break;
        }
        rightStoredPowerup = null; // Powerup consumed
      }
    }
    //scores to be displayed from frontend
    function getLeftScore(){
      return leftscore;
    }
    function getRightScore(){
      return rightscore;
    }
    //powerups to be displayed from frontend
    function getLeftStoredPowerup(){
      return leftStoredPowerup;
    }
    function getRightStoredPowerup(){
      return rightStoredPowerup;
    }
    //powerup instructions to  be displayed from frontend (PRESS Q TO USE, PRESS P TO USE)

    //powerup timers to be displayed from frontend 
    function getLeftTimeLeft(){
      return leftSeconds;
    }
    function getRightTimeLeft(){
      return rightSeconds;
    }
    function drawUI() {
      // Scores
      fill(255);
      textAlign(LEFT);
      textSize(32);
      text(leftscore, 350, 40);
      text("-", 390, 40);
      textAlign(RIGHT);
      text(rightscore, 467, 40);

      // Draw powerup icons for each player
      drawPowerupIcon(leftStoredPowerup, 60, 100, 'left');
      drawPowerupIcon(rightStoredPowerup, GAME_WIDTH - 60, 100, 'right');

      // Draw powerup instructions
      fill(255, 255, 0); // Yellow color for instructions
      textAlign(LEFT);
      textSize(12);
      text("P1: Q to use", 20, 140);
      
      textAlign(RIGHT);
      text("P2: P to use", GAME_WIDTH - 20, 140);


      // Display individual powerup cooldown timers at the bottom
      let currentTime = millis();

      // Player 1 Powerup Cooldown
      let leftTimeLeft = leftPowerupCooldownEnd - currentTime;
      let leftSeconds = Math.max(0, Math.ceil(leftTimeLeft / 1000));
      fill(0, 255, 0);
      textAlign(LEFT);
      textSize(16);
      text("P1 Next: " + leftSeconds + "s", 20, GAME_HEIGHT - 20);

      // Player 2 Powerup Cooldown
      let rightTimeLeft = rightPowerupCooldownEnd - currentTime;
      let rightSeconds = Math.max(0, Math.ceil(rightTimeLeft / 1000));
      fill(0, 255, 0);
      textAlign(RIGHT);
      textSize(16);
      text("P2 Next: " + rightSeconds + "s", GAME_WIDTH - 20, GAME_HEIGHT - 20);

       // Display active powerup effects duration if any
      fill(255, 150, 0); // Orange for active effects

      if (leftPowerupActive) {
        let timeLeft = leftPowerupEffectEndTime - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(LEFT);
        textSize(10);
        text("P1 Effect: " + seconds + "s", 20, GAME_HEIGHT - 50);
      }

      if (rightPowerupActive) {
        let timeLeft = rightPowerupEffectEndTime - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(RIGHT);
        textSize(10);
        text("P2 Effect: " + seconds + "s", GAME_WIDTH - 20, GAME_HEIGHT - 50);
      }

      if (ballFrozen) {
        let timeLeft = ballFrozenEndTime - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(CENTER);
        textSize(10);
        text("Ball Frozen: " + seconds + "s", GAME_WIDTH / 2, GAME_HEIGHT - 50);
      } else if (ballSpeedMultiplier > 1 && !magicActive) {
        let timeLeft = ballFrozenEndTime - currentTime; // Re-using for fireball duration
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(CENTER);
        textSize(10);
        text("Fireball: " + seconds + "s", GAME_WIDTH / 2, GAME_HEIGHT - 50);
      }

      if (magicActive) {
        let timeLeft = magicEffectEndTime - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(CENTER);
        textSize(10);
        text("Magic Ball: " + seconds + "s", GAME_WIDTH / 2, GAME_HEIGHT - 70);
      }

      if (forceFieldActive.left) {
        let timeLeft = forceFieldEffectEndTime.left - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(LEFT);
        textSize(10);
        text("P1 Force Field: " + seconds + "s", 20, GAME_HEIGHT - 70);
      }

      if (forceFieldActive.right) {
        let timeLeft = forceFieldEffectEndTime.right - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(RIGHT);
        textSize(10);
        text("P2 Force Field: " + seconds + "s", GAME_WIDTH - 20, GAME_HEIGHT - 70);
      }

      if (brokenKeyboardActive.left) {
        let timeLeft = brokenKeyboardEffectEndTime.left - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(LEFT);
        textSize(10);
        text("P1 Controls Reversed: " + seconds + "s", 20, GAME_HEIGHT - 90);
      }
      if (brokenKeyboardActive.right) {
        let timeLeft = brokenKeyboardEffectEndTime.right - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(RIGHT);
        textSize(10);
        text("P2 Controls Reversed: " + seconds + "s", GAME_WIDTH - 20, GAME_HEIGHT - 90);
      }
    }

    function drawPowerupIcon(powerupType, x, y, player) {
      // Only draw if there's a stored powerup
      if (!powerupType) {
        // Draw an empty slot if no powerup is stored
        fill(30); // Darker fill for empty slot
        stroke(100); // Lighter border
        strokeWeight(2);
        rect(x - 20, y - 20, 40, 40);
        return; 
      }

      // Draw powerup background
      fill(50);
      stroke(255);
      strokeWeight(2);
      rect(x - 20, y - 20, 40, 40);

      // Draw powerup icon (colored squares as placeholders)
      noStroke();
      switch (powerupType) {
        case 'freeze':
          fill(100, 150, 255);
          break;
        case 'fireball':
          fill(255, 100, 100);
          break;
        case 'xl':
          fill(100, 255, 100);
          break;
        case 'mini':
          fill(255, 255, 100);
          break;
        case 'magic':
          fill(200, 0, 200); // Purple
          break;
        case 'forcefield':
          fill(0, 150, 255); // Sky blue
          break;
        case 'brokenKeyboard':
          fill(255, 0, 0); // Red for warning
          break;
      }
      rect(x - 10, y - 10, 20, 20);

      // Draw powerup name
      fill(255);
      textAlign(CENTER);
      textSize(8);
      text(powerupType.toUpperCase(), x, y + 30);
    }

    function drawForceField(x, y, player) {
      push();
      noFill();
      stroke(173, 216, 230); // Light blue color
      strokeWeight(4);
      if (player === 'left') {
        arc(x, y, 140, 140, -PI / 2, PI / 2); // Arc facing right
      } else {
        arc(x, y, 140, 140, PI / 2, 3 * PI / 2); // Arc facing left
      }
      pop();
    }


    function calculateCanvasSize() {
      let maxWidth = windowWidth * 0.95;
      let maxHeight = windowHeight * 0.85;
      scaleFactor = min(maxWidth / GAME_WIDTH, maxHeight / GAME_HEIGHT);
    }

    function windowResized() {
      calculateCanvasSize();
      resizeCanvas(GAME_WIDTH * scaleFactor, GAME_HEIGHT * scaleFactor);
    }

    function keyReleased() {
      if (gameStarted) {
        // Stop paddle movement when key is released
        if (key.toUpperCase() === 'W' || key.toUpperCase() === 'S') {
            left.move(0);
        } else if (key.toUpperCase() === 'I' || key.toUpperCase() === 'K') {
            right.move(0);
        }
      }
    }

    function keyPressed() {
      if (!gameStarted) return;
      let k = key.toUpperCase();
      
      // Movement controls
      if (k === 'W') {
        if (brokenKeyboardActive.left) left.move(10); // Reversed
        else left.move(-10);
      } else if (k === 'S') {
        if (brokenKeyboardActive.left) left.move(-10); // Reversed
        else left.move(10);
      } else if (k === 'I') {
        if (brokenKeyboardActive.right) right.move(10); // Reversed
        else right.move(-10);
      } else if (k === 'K') {
        if (brokenKeyboardActive.right) right.move(-10); // Reversed
        else right.move(10);
      }
      
      // Powerup activation
      else if (k === 'Q') activatePowerup('left');
      else if (k === 'P') activatePowerup('right');
    }

    function mousePressed() {
      // Only trigger if we are still on the start screen
      if (showStartScreen) {
        if (!countdownStarted) {
          countdown.play(); // Play the countdown sound
          countdownStarted = true; // Mark that countdown has started
          
          // After the countdown, transition to gameStarted
          setTimeout(() => {
            showStartScreen = false;
            gameStarted = true;
          }, 3000); // 4 seconds for the countdown
        }
        // Prevent multiple plays if user clicks rapidly
        return;
      }
    }
  </script>
</body>
</html>