<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rumble Pong Game</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      font-family: "Press Start 2P", cursive;
      background: black;
      color: white;
      height: 100%;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }

    canvas {
      border: 2px solid #00ff00;
      display: block;
    }

    .menu-button {
      position: fixed;
      top: 20px;
      left: 20px;
      font-family: "Press Start 2P", cursive;
      padding: 10px 14px;
      font-size: 10px;
      color: #00ff00;
      border: 2px solid #00ff00;
      background: transparent;
      cursor: pointer;
      transition: transform 0.2s;
      white-space: nowrap;
      text-decoration: none;
    }

    .menu-button:hover {
      transform: scale(1.05);
      background: rgba(0, 255, 0, 0.1);
    }

    @media (max-width: 600px) {
      .menu-button {
        font-size: 8px;
        padding: 6px 10px;
      }
    }
  </style>
</head>
<body>
  <a href="Main Menu.html" class="menu-button">‚Üê Back to Menu</a>

  <script>
    let leftscore = 0;
    let rightscore = 0;
    let puck, left, right;
    let audioEnabled = false; // Flag to enable audio after user interaction
    let gameStarted = false;
    let showStartScreen = true;
    let canvas;
    let goalSound; // Declare a variable for the Audio object
    const beepSound = 'data:audio/wav;base64,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VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/70mQAD/AAAGkAAAAIAAANIAAAAQAAAaQAAAAgAAA0gAAABExBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMQU1FMy4xMDBVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV//vSZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU=';

    // Power-up variables for each player
    let leftStoredPowerup = null; // Stores the powerup for player 1
    let rightStoredPowerup = null; // Stores the powerup for player 2
    let leftPowerupCooldownEnd = 0; // When player 1 can get a new powerup
    let rightPowerupCooldownEnd = 0; // When player 2 can get a new powerup

    // Existing power-up effect tracking
    let leftPowerupActive = false;
    let rightPowerupActive = false;
    let leftPowerupEffectEndTime = 0; // Changed name for clarity
    let rightPowerupEffectEndTime = 0; // Changed name for clarity
    let ballFrozen = false;
    let ballFrozenEndTime = 0;
    let ballSpeedMultiplier = 1;

    // New Power-up variables
    let magicActive = false;
    let magicEffectEndTime = 0;
    const MAGIC_DURATION = 5000; // 5 seconds

    let forceFieldActive = { left: false, right: false };
    let forceFieldEffectEndTime = { left: 0, right: 0 };
    const FORCE_FIELD_DURATION = 4000; // 4 seconds

    let brokenKeyboardActive = { left: false, right: false }; // Tracks if the *other* player's controls are reversed
    let brokenKeyboardEffectEndTime = { left: 0, right: 0 };
    const BROKEN_KEYBOARD_DURATION = 5000; // 5 seconds


    let leftOriginalHeight = 100; // Store original height
    let rightOriginalHeight = 100; // Store original height
    let powerupImages = {};

    const POWERUP_TYPES = ['freeze', 'fireball', 'xl', 'mini', 'magic', 'forcefield', 'brokenKeyboard'];
    const POWERUP_COOLDOWN_DURATION = 8000; // 8 seconds before a new powerup is given
    const POWERUP_EFFECT_DURATION = 3000; // 3 seconds for most effects (used for freeze, fireball, xl, mini)

    const GAME_WIDTH = 800;
    const GAME_HEIGHT = 600;
    let scaleFactor = 1;

    // Load powerup images (placeholder names)
    function preload() {
      // Note: These would be actual image files in a real implementation
      // For now, we'll create placeholder colored rectangles
      powerupImages.freeze = null; // freeze.png
      powerupImages.fireball = null; // fireball.png
      powerupImages.xl = null; // xl.png
      powerupImages.mini = null; // mini.png
      powerupImages.magic = null; // magic.png
      powerupImages.forcefield = null; // forcefield.png
      powerupImages.brokenKeyboard = null; // brokenKeyboard.png
    }

    class Paddle {
      constructor(isLeft) {
        this.w = 20;
        this.h = 100;
        this.originalH = 100; // Store initial height
        this.y = GAME_HEIGHT / 2;
        this.ychange = 0;
        this.x = isLeft ? this.w : GAME_WIDTH - this.w;
        this.isLeft = isLeft;
      }

      update() {
        this.y += this.ychange;
        this.y = constrain(this.y, this.h / 2, GAME_HEIGHT - this.h / 2);
      }

      move(steps) {
        this.ychange = steps;
      }

      show() {
        fill(255);
        rectMode(CENTER);
        rect(this.x, this.y, this.w, this.h);
      }

      resize(newHeight) {
        this.h = newHeight;
      }

      resetSize() {
        this.h = this.originalH;
      }
    }

    class Puck {
      constructor() {
        this.r = 12;
        this.reset();
        this.firstTime = true;
      }

      reset() {
        this.x = GAME_WIDTH / 2;
        this.y = GAME_HEIGHT / 2;
        let angle = random(-PI / 4, PI / 4);
        this.xspeed = 5 * cos(angle);
        this.yspeed = 5 * sin(angle);
        if (random(1) < 0.5) this.xspeed *= -1;
        ballSpeedMultiplier = 1; // Reset ball speed
        ballFrozen = false; // Ensure ball is unfrozen on reset
        magicActive = false; // Ensure magic is off on reset
      }
      
      update() {
      if (!ballFrozen) {
        let lastAngleChange = 0;
        if (magicActive) {
          const currTime = millis();
          
          // Initialize lastAngleChange if it doesn't exist
          if (!this.lastAngleChange) {
            this.lastAngleChange = currTime;
          }
          
          // Check if 0.5 seconds (500ms) have passed
          if (currTime - this.lastAngleChange >= 600) {
            let newAngle = random(0, 2*PI);
            let currentSpeed = sqrt(this.xspeed * this.xspeed + this.yspeed * this.yspeed);
            this.xspeed = currentSpeed * cos(newAngle);
            this.yspeed = currentSpeed * sin(newAngle);
            
            if (this.xspeed > 0 && this.x > GAME_WIDTH / 2) this.xspeed *= -1;
            if (this.xspeed < 0 && this.x < GAME_WIDTH / 2) this.xspeed *= -1;
            
            // Update the last angle change time
            this.lastAngleChange = currTime;
            ballSpeedMultiplier+=2;
          }
        }
        
        this.x += this.xspeed * ballSpeedMultiplier;
        this.y += this.yspeed * ballSpeedMultiplier;
      }
}

      edges() {
        if (this.y < 0 || this.y > GAME_HEIGHT) this.yspeed *= -1;

        // Check for goal conditions
        if (this.x - this.r > GAME_WIDTH) {
          leftscore++;
          if (audioEnabled) {
            goalSound.play(); // Play sound on goal
          }
          this.reset();
        }
        if (this.x + this.r < 0) {
          rightscore++;
          if (audioEnabled) {
            goalSound.play(); // Play sound on goal
          }
          this.reset();
        }
      }

      checkPaddle(p) {
        if (
          this.y - this.r < p.y + p.h / 2 &&
          this.y + this.r > p.y - p.h / 2 &&
          ((this.x - this.r < p.x + p.w / 2 && this.x > p.x) ||
           (this.x + this.r > p.x - p.w / 2 && this.x < p.x))
        ) {
          // Calculate angle based on where it hits the paddle
          let diff = this.y - (p.y - p.h / 2);
          let angle = map(diff, 0, p.h, p.x < GAME_WIDTH / 2 ? -PI / 4 : (5 * PI) / 4, p.x < GAME_WIDTH / 2 ? PI / 4 : (3 * PI) / 4);
          this.xspeed = 5 * cos(angle);
          this.yspeed = 5 * sin(angle);

          // Prevent ball from sticking to paddle
          this.x = p.x < GAME_WIDTH / 2 ? p.x + p.w / 2 + this.r : p.x - p.w / 2 - this.r;
        }
      }

      checkForceField(player) {
        let fieldX, fieldY, fieldRadius;
        if (player === 'left') {
          fieldX = left.x + left.w / 2 + 50; // Position the arc in front of the paddle
          fieldY = left.y;
          fieldRadius = 70;
          // Check if ball is within the arc's X range
          if (this.x + this.r > left.x + left.w / 2 && this.x - this.r < fieldX + fieldRadius) {
            // Check approximate collision with the arc
            let distToCenter = dist(this.x, this.y, fieldX, fieldY);
            if (distToCenter < fieldRadius + this.r && distToCenter > fieldRadius - this.r) {
              // Calculate angle from center of arc to ball
              let angleToBall = atan2(this.y - fieldY, this.x - fieldX);
              // Only bounce if ball is moving towards the field and within the arc's "front"
              if (this.xspeed < 0 && angleToBall > -PI/2 && angleToBall < PI/2) {
                this.xspeed *= -1; // Reverse X direction
                // Optional: Adjust Y speed based on hit point on the arc
                this.yspeed = (this.y - fieldY) * 0.1; // Example, can be more sophisticated
              }
            }
          }
        } else if (player === 'right') {
          fieldX = right.x - right.w / 2 - 50; // Position the arc in front of the paddle
          fieldY = right.y;
          fieldRadius = 70;
          // Check if ball is within the arc's X range
          if (this.x - this.r < right.x - right.w / 2 && this.x + this.r > fieldX - fieldRadius) {
            // Check approximate collision with the arc
            let distToCenter = dist(this.x, this.y, fieldX, fieldY);
            if (distToCenter < fieldRadius + this.r && distToCenter > fieldRadius - this.r) {
              // Calculate angle from center of arc to ball
              let angleToBall = atan2(this.y - fieldY, this.x - fieldX);
              // Only bounce if ball is moving towards the field and within the arc's "front"
              if (this.xspeed > 0 && (angleToBall > PI/2 || angleToBall < -PI/2)) {
                this.xspeed *= -1; // Reverse X direction
                // Optional: Adjust Y speed based on hit point on the arc
                this.yspeed = (this.y - fieldY) * 0.1; // Example, can be more sophisticated
              }
            }
          }
        }
      }

      show() {
        if (ballFrozen) {
          fill(100, 150, 255); // Blue tint when frozen
        } else if (ballSpeedMultiplier > 1) {
          fill(255, 100, 100); // Red tint when in fireball mode
        } else {
          fill(255);
        }
        ellipse(this.x, this.y, this.r * 2);
      }
    }

    function setup() {
      calculateCanvasSize();
      canvas = createCanvas(GAME_WIDTH * scaleFactor, GAME_HEIGHT * scaleFactor);
      canvas.parent(document.body);
      puck = new Puck();
      left = new Paddle(true);
      right = new Paddle(false);

      // Initialize powerup cooldowns for both players
      leftPowerupCooldownEnd = millis() + POWERUP_COOLDOWN_DURATION;
      rightPowerupCooldownEnd = millis() + POWERUP_COOLDOWN_DURATION;

      // Initialize the Audio object here. It expects `beepSound` to be globally available.
      goalSound = new Audio(beepSound);
      goalSound.volume = 0.5; // Adjust volume if needed

      // Set initial state after a delay or user interaction
      setTimeout(() => {
        if (showStartScreen) {
          showStartScreen = false;
          gameStarted = true;
          // Audio enabled here assumes the timeout counts as initial interaction.
          // For stricter browser autoplay policies, mousePressed is more reliable.
          audioEnabled = true; 
        }
      }, 4000);
    }

    function draw() {
      scale(scaleFactor);
      background(0);

      if (showStartScreen) {
        fill(255);
        textAlign(CENTER);
        textSize(24);
        text("Rumble Pong!", GAME_WIDTH / 2, GAME_HEIGHT / 2 - 50);
        textSize(16);
        text("Player 1: W/S | Player 2: I/K", GAME_WIDTH / 2, GAME_HEIGHT / 2 + 25);
        textSize(12);
        text("Press Q and P for Powerups!", GAME_WIDTH / 2, GAME_HEIGHT / 2 + 50);
        return;
      }

      // Update powerup cooldowns and effects
      updatePowerups();

      puck.checkPaddle(left);
      puck.checkPaddle(right);

      // Check for force field collisions
      if (forceFieldActive.left) {
        puck.checkForceField('left');
      }
      if (forceFieldActive.right) {
        puck.checkForceField('right');
      }

      left.update();
      right.update();
      puck.update();
      puck.edges();

      left.show();
      right.show();
      puck.show();

      // Draw UI
      drawUI();

      // Draw active force fields
      if (forceFieldActive.left) {
        drawForceField(left.x + left.w / 2 + 50, left.y, 'left');
      }
      if (forceFieldActive.right) {
        drawForceField(right.x - right.w / 2 - 50, right.y, 'right');
      }
    }

    function updatePowerups() {
      let currentTime = millis();
      
      // Check and give powerup for Player 1
      if (leftStoredPowerup === null && currentTime >= leftPowerupCooldownEnd) {
        leftStoredPowerup = random(POWERUP_TYPES);
        leftPowerupCooldownEnd = currentTime + POWERUP_COOLDOWN_DURATION; // Reset cooldown
      }

      // Check and give powerup for Player 2
      if (rightStoredPowerup === null && currentTime >= rightPowerupCooldownEnd) {
        rightStoredPowerup = random(POWERUP_TYPES);
        rightPowerupCooldownEnd = currentTime + POWERUP_COOLDOWN_DURATION; // Reset cooldown
      }

      // Check if ball freeze should end
      if (ballFrozen && currentTime >= ballFrozenEndTime) {
        ballFrozen = false;
      }

      // Check if fireball effect should end (ballSpeedMultiplier > 1 means it's active)
      if (ballSpeedMultiplier > 1 && currentTime >= ballFrozenEndTime) { // Using ballFrozenEndTime for fireball as well
        ballSpeedMultiplier = 1;
      }

      // Check if paddle size effects should end for Player 1
      if (leftPowerupActive && currentTime >= leftPowerupEffectEndTime) {
        left.resetSize();
        leftPowerupActive = false;
      }

      // Check if paddle size effects should end for Player 2
      if (rightPowerupActive && currentTime >= rightPowerupEffectEndTime) {
        right.resetSize();
        rightPowerupActive = false;
      }

      // Check if Magic effect should end
      if (magicActive && currentTime >= magicEffectEndTime) {
        magicActive = false;
      }

      // Check if Force Field effects should end
      if (forceFieldActive.left && currentTime >= forceFieldEffectEndTime.left) {
        forceFieldActive.left = false;
      }
      if (forceFieldActive.right && currentTime >= forceFieldEffectEndTime.right) {
        forceFieldActive.right = false;
      }

      // Check if Broken Keyboard effects should end
      if (brokenKeyboardActive.left && currentTime >= brokenKeyboardEffectEndTime.left) {
        brokenKeyboardActive.left = false;
      }
      if (brokenKeyboardActive.right && currentTime >= brokenKeyboardEffectEndTime.right) {
        brokenKeyboardActive.right = false;
      }
    }

    function activatePowerup(player) {
      let currentTime = millis();
      
      if (player === 'left' && leftStoredPowerup) {
        switch (leftStoredPowerup) {
          case 'freeze':
            ballFrozen = true;
            ballFrozenEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'fireball':
            ballSpeedMultiplier = 2;
            ballFrozenEndTime = currentTime + POWERUP_EFFECT_DURATION; // Use same timer for simplicity
            break;
          case 'xl':
            left.resize(left.originalH * 1.5); // Make left paddle 50% larger
            leftPowerupActive = true;
            leftPowerupEffectEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'mini':
            right.resize(right.originalH * 0.5); // Make right paddle 50% smaller
            leftPowerupActive = true;
            leftPowerupEffectEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'magic':
            magicActive = true;
            magicEffectEndTime = currentTime + MAGIC_DURATION;
            break;
          case 'forcefield':
            forceFieldActive.left = true;
            forceFieldEffectEndTime.left = currentTime + FORCE_FIELD_DURATION;
            break;
          case 'brokenKeyboard':
            brokenKeyboardActive.right = true; // Player 1 activates, Player 2's controls are reversed
            brokenKeyboardEffectEndTime.right = currentTime + BROKEN_KEYBOARD_DURATION;
            break;
        }
        leftStoredPowerup = null; // Powerup consumed
      } else if (player === 'right' && rightStoredPowerup) {
        switch (rightStoredPowerup) {
          case 'freeze':
            ballFrozen = true;
            ballFrozenEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'fireball':
            ballSpeedMultiplier = 2;
            ballFrozenEndTime = currentTime + POWERUP_EFFECT_DURATION; // Use same timer for simplicity
            break;
          case 'xl':
            right.resize(right.originalH * 1.5); // Make right paddle 50% larger
            rightPowerupActive = true;
            rightPowerupEffectEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'mini':
            left.resize(left.originalH * 0.5); // Make left paddle 50% smaller
            rightPowerupActive = true;
            rightPowerupEffectEndTime = currentTime + POWERUP_EFFECT_DURATION;
            break;
          case 'magic':
            magicActive = true;
            magicEffectEndTime = currentTime + MAGIC_DURATION;
            break;
          case 'forcefield':
            forceFieldActive.right = true;
            forceFieldEffectEndTime.right = currentTime + FORCE_FIELD_DURATION;
            break;
          case 'brokenKeyboard':
            brokenKeyboardActive.left = true; // Player 2 activates, Player 1's controls are reversed
            brokenKeyboardEffectEndTime.left = currentTime + BROKEN_KEYBOARD_DURATION;
            break;
        }
        rightStoredPowerup = null; // Powerup consumed
      }
    }
    //scores to be displayed from frontend
    function getLeftScore(){
      return leftscore;
    }
    function getRightScore(){
      return rightscore;
    }
    //powerups to be displayed from frontend
    function getLeftStoredPowerup(){
      return leftStoredPowerup;
    }
    function getRightStoredPowerup(){
      return rightStoredPowerup;
    }
    //powerup instructions to  be displayed from frontend (PRESS Q TO USE, PRESS P TO USE)

    //powerup timers to be displayed from frontend 
    function getLeftTimeLeft(){
      return leftSeconds;
    }
    function getRightTimeLeft(){
      return rightSeconds;
    }
    function drawUI() {
      // Scores
      fill(255);
      textAlign(LEFT);
      textSize(32);
      text(leftscore, 20, 40);

      textAlign(RIGHT);
      text(rightscore, GAME_WIDTH - 20, 40);

      // Draw powerup icons for each player
      drawPowerupIcon(leftStoredPowerup, 60, 100, 'left');
      drawPowerupIcon(rightStoredPowerup, GAME_WIDTH - 60, 100, 'right');

      // Draw powerup instructions
      fill(255, 255, 0); // Yellow color for instructions
      textAlign(LEFT);
      textSize(12);
      text("P1: Q to use", 20, 140);
      
      textAlign(RIGHT);
      text("P2: P to use", GAME_WIDTH - 20, 140);


      // Display individual powerup cooldown timers at the bottom
      let currentTime = millis();

      // Player 1 Powerup Cooldown
      let leftTimeLeft = leftPowerupCooldownEnd - currentTime;
      let leftSeconds = Math.max(0, Math.ceil(leftTimeLeft / 1000));
      fill(0, 255, 0);
      textAlign(LEFT);
      textSize(16);
      text("P1 Next: " + leftSeconds + "s", 20, GAME_HEIGHT - 20);

      // Player 2 Powerup Cooldown
      let rightTimeLeft = rightPowerupCooldownEnd - currentTime;
      let rightSeconds = Math.max(0, Math.ceil(rightTimeLeft / 1000));
      fill(0, 255, 0);
      textAlign(RIGHT);
      textSize(16);
      text("P2 Next: " + rightSeconds + "s", GAME_WIDTH - 20, GAME_HEIGHT - 20);

       // Display active powerup effects duration if any
      fill(255, 150, 0); // Orange for active effects

      if (leftPowerupActive) {
        let timeLeft = leftPowerupEffectEndTime - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(LEFT);
        textSize(10);
        text("P1 Effect: " + seconds + "s", 20, GAME_HEIGHT - 50);
      }

      if (rightPowerupActive) {
        let timeLeft = rightPowerupEffectEndTime - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(RIGHT);
        textSize(10);
        text("P2 Effect: " + seconds + "s", GAME_WIDTH - 20, GAME_HEIGHT - 50);
      }

      if (ballFrozen) {
        let timeLeft = ballFrozenEndTime - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(CENTER);
        textSize(10);
        text("Ball Frozen: " + seconds + "s", GAME_WIDTH / 2, GAME_HEIGHT - 50);
      } else if (ballSpeedMultiplier > 1) {
        let timeLeft = ballFrozenEndTime - currentTime; // Re-using for fireball duration
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(CENTER);
        textSize(10);
        text("Fireball: " + seconds + "s", GAME_WIDTH / 2, GAME_HEIGHT - 50);
      }

      if (magicActive) {
        let timeLeft = magicEffectEndTime - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(CENTER);
        textSize(10);
        text("Magic Ball: " + seconds + "s", GAME_WIDTH / 2, GAME_HEIGHT - 70);
      }

      if (forceFieldActive.left) {
        let timeLeft = forceFieldEffectEndTime.left - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(LEFT);
        textSize(10);
        text("P1 Force Field: " + seconds + "s", 20, GAME_HEIGHT - 70);
      }

      if (forceFieldActive.right) {
        let timeLeft = forceFieldEffectEndTime.right - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(RIGHT);
        textSize(10);
        text("P2 Force Field: " + seconds + "s", GAME_WIDTH - 20, GAME_HEIGHT - 70);
      }

      if (brokenKeyboardActive.left) {
        let timeLeft = brokenKeyboardEffectEndTime.left - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(LEFT);
        textSize(10);
        text("P1 Controls Reversed: " + seconds + "s", 20, GAME_HEIGHT - 90);
      }
      if (brokenKeyboardActive.right) {
        let timeLeft = brokenKeyboardEffectEndTime.right - currentTime;
        let seconds = Math.max(0, Math.ceil(timeLeft / 1000));
        textAlign(RIGHT);
        textSize(10);
        text("P2 Controls Reversed: " + seconds + "s", GAME_WIDTH - 20, GAME_HEIGHT - 90);
      }
    }

    function drawPowerupIcon(powerupType, x, y, player) {
      // Only draw if there's a stored powerup
      if (!powerupType) {
        // Draw an empty slot if no powerup is stored
        fill(30); // Darker fill for empty slot
        stroke(100); // Lighter border
        strokeWeight(2);
        rect(x - 20, y - 20, 40, 40);
        return; 
      }

      // Draw powerup background
      fill(50);
      stroke(255);
      strokeWeight(2);
      rect(x - 20, y - 20, 40, 40);

      // Draw powerup icon (colored squares as placeholders)
      noStroke();
      switch (powerupType) {
        case 'freeze':
          fill(100, 150, 255);
          break;
        case 'fireball':
          fill(255, 100, 100);
          break;
        case 'xl':
          fill(100, 255, 100);
          break;
        case 'mini':
          fill(255, 255, 100);
          break;
        case 'magic':
          fill(200, 0, 200); // Purple
          break;
        case 'forcefield':
          fill(0, 150, 255); // Sky blue
          break;
        case 'brokenKeyboard':
          fill(255, 0, 0); // Red for warning
          break;
      }
      rect(x - 10, y - 10, 20, 20);

      // Draw powerup name
      fill(255);
      textAlign(CENTER);
      textSize(8);
      text(powerupType.toUpperCase(), x, y + 30);
    }

    function drawForceField(x, y, player) {
      push();
      noFill();
      stroke(173, 216, 230); // Light blue color
      strokeWeight(4);
      if (player === 'left') {
        arc(x, y, 140, 140, -PI / 2, PI / 2); // Arc facing right
      } else {
        arc(x, y, 140, 140, PI / 2, 3 * PI / 2); // Arc facing left
      }
      pop();
    }


    function calculateCanvasSize() {
      let maxWidth = windowWidth * 0.95;
      let maxHeight = windowHeight * 0.85;
      scaleFactor = min(maxWidth / GAME_WIDTH, maxHeight / GAME_HEIGHT);
    }

    function windowResized() {
      calculateCanvasSize();
      resizeCanvas(GAME_WIDTH * scaleFactor, GAME_HEIGHT * scaleFactor);
    }

    function keyReleased() {
      if (gameStarted) {
        // Stop paddle movement when key is released
        if (key.toUpperCase() === 'W' || key.toUpperCase() === 'S') {
            left.move(0);
        } else if (key.toUpperCase() === 'I' || key.toUpperCase() === 'K') {
            right.move(0);
        }
      }
    }

    function keyPressed() {
      if (!gameStarted) return;
      let k = key.toUpperCase();
      
      // Movement controls
      if (k === 'W') {
        if (brokenKeyboardActive.left) left.move(10); // Reversed
        else left.move(-10);
      } else if (k === 'S') {
        if (brokenKeyboardActive.left) left.move(-10); // Reversed
        else left.move(10);
      } else if (k === 'I') {
        if (brokenKeyboardActive.right) right.move(10); // Reversed
        else right.move(-10);
      } else if (k === 'K') {
        if (brokenKeyboardActive.right) right.move(-10); // Reversed
        else right.move(10);
      }
      
      // Powerup activation
      else if (k === 'Q') activatePowerup('left');
      else if (k === 'P') activatePowerup('right');
    }

    function mousePressed() {
      // This is crucial for audio to play in modern browsers,
      // as they often require a user gesture to enable audio.
      if (!gameStarted && showStartScreen) { // Only run if on start screen and game hasn't started
        showStartScreen = false;
        gameStarted = true;
        audioEnabled = true; // Enable audio playback after user interaction

        // Initialize powerup cooldowns on game start by mouse click as well
        leftPowerupCooldownEnd = millis() + POWERUP_COOLDOWN_DURATION;
        rightPowerupCooldownEnd = millis() + POWERUP_COOLDOWN_DURATION;
      }
    }
  </script>
</body>
</html>